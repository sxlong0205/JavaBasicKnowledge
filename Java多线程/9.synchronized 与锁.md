Java 多线程的锁都是基于对象的，常听到的类锁其实也是对象所。

## synchronized关键字

synchronized 关键字通常有三种形式：

1. 关键字在实例方法上，锁为当前实例
2. 关键字在静态方法上，锁为当前 Class 对象
3. 关键字在代码块上，锁为括号里面的对象

所谓“临界区”，指的是某一块代码区域，它同一时刻只能由一个线程执行。


等价写法
```java
public synchronized void instanceLock() {
    //code 
}

public void blockLock() {
    synchronized (this) {
        // code
    }
}
```

## 锁

Java 6 为了减少锁开销，引入了"偏向锁"和"轻量级锁"。在 Java 6 之后一个对象一共有四种锁状态：
1. 无所状态
2. 偏向锁
3. 轻量级锁
4. 重量级锁

锁升级很容易，但是降级发生的条件比较苛刻，锁降级发生在 Stop The World 期间
> 实际上 HotSpot JVM 是支持锁降级的，[具体参考](https://www.jianshu.com/p/9932047a89be)

### Java 对象头

Java 的锁都是基于对象的，锁信息一般存放在 Java 对象头中，如果是非数组类型，则用 2 个字宽来存储对象头，如果是数组，则会用 3 个字宽来存储对象头。

在 32 位处理器中，一个字宽是 32 位；在 64 位虚拟机中，一个字宽是 64 位。

锁状态 | 29 bit 或 61 bit | 1 bit 是否是偏向锁？ | 2 bit 锁标志位
---|---|---|---
无锁 |  | 0 | 01
偏向锁 | 线程 ID | 1 | 01
轻量级锁 | 指向栈中锁记录的指针 |  此时这一位不用于标识偏向锁 | 00
重量级锁 | 指向互斥量(重量级锁)的指针 | 此时这一位不用于标识偏向锁 | 10
GC 标记 |  | 此时这一位不用于标识偏向锁 | 11

当对象状态为偏向锁时，Mark Word 存储的是偏向的线程 ID；当状态为轻量级锁时，Mark Word 存储的是指向线程中 Lock Record 的指针；当状态为重量级锁时，Mark Word 为指向堆中的 monitor 对象的指针。

### 偏向锁

大多数情况下，锁不仅不存在多线程竞争，而是总是由同一线程多次获得，于是引入了偏向锁。

偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。

一个线程在第一个进入同步块时，会在对象头和栈帧中的锁记录里存储锁的偏向的线程 ID。当下次该线程进入这个同步块时，回去检查锁的 Mark Word 里面是不是放的自己的线程 ID。如果是，表明该线程已经获得了锁，以后该线程在进入和退出同步块时不需要花费 CAS 操作来加锁和解锁；如果不是，就代表有另一个线程来竞争这个偏向锁。这个时候会尝试使用 CAS 来替换 Mark Word 里面的线程 ID 为新线程的 ID，这时要分两种情况：
- 成功，表示之前的线程不存在了，Mark Word 里面的线程 ID 为新线程的 ID，锁不会升级，仍然为偏向锁；
- 失败，表示之前的线程仍然存在，那么暂停之前的线程，设置偏向锁标识为 0，并设置锁标志位为 00，升级为轻量级锁，会按照轻量级锁的方式进行竞争锁。

> CAS : Compare And Swap，用于硬件层面上提供原子性操作，在 Intel 处理器中，比较并交换通过指令 cmpxchg 实现。比较是否和给定的数值一致，如果一致则修改，不一致则不修改。

偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。

偏向锁撤销过程：
1. 在一个安全点停止拥有锁的线程；
2. 遍历线程栈，如果存在锁记录的话，需要修复锁记录和 Mark Word，使其变成无锁状态；
3. 唤醒被停止的线程，将当前锁升级成轻量级锁。


通过`-XX:UseBiasedLocking=false`关闭偏向锁

### 轻量级锁

JVM 会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，我们称为 Displaced Mark Word。如果一个线程获得锁的时候发现是轻量级锁，会把锁的 Mark Word 复制到自己的 Displaced Mark Word 里面，然后线程尝试用 CAS 将锁的 Mark Word 替换为指向锁记录的指针。如果竞争失败就需要通过自旋来获取锁。
> 自旋：不断尝试去获取锁，一般用循环来实现

自旋是需要消耗CPU的，如果一直获取不到锁，就会一直自旋，浪费CPU资源，通常解决办法就是限制自旋次数，**JDK 采用适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。**


自旋不是无限制进行下去的，如果自旋到一定的程度(和 JVM、操作系统相关)，依然没有获取到锁，称为自旋失败，那么这个线程就会阻塞，同时这个锁会升级成重量级锁。

在释放锁时，当前线程会使用 CAS 操作将 Displaced Mark Word 的内容复制回锁的 Mark Word 里面。如果没有发生竞争，那么这个复制的操作会成功。如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么 CAS 操作会失败，此时会释放锁并唤醒被阻塞的线程。

### 重量级锁

重量级锁依赖于操作系统的互斥量(mutex)实现的，而操作系统中线程间状态的转换需要相对比较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗 CPU。

当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个 ObjectWaiter 对象插入到 Contention List 的队列的队首，然后调用 park 函数挂起当前线程。

当线程释放锁时，会从 Contention List 或 EntryList 中挑选一个线程唤醒，被选中的线程叫做 Heir presumptive 即假定继承人，假定继承人被唤醒后会尝试获得锁，但 synchronized 是非公平的，所以假定继承人不一定能获得锁。这是因为对于重量级锁，线程先自旋尝试获得锁，**这样做的目的是为了减少执行操作系统同步操作带来的开销**。如果自旋不成功再进入等待队列。这对那些已经在等待队列中的线程来说，稍微显得不公平，还有一个不公平的地方是自旋线程可能会抢占了 Ready 线程的锁。

如果线程获得锁后调用 Object.wait 方法，则会将线程加入到 WaitSet 中，当被 Object.notify 唤醒后，会将线程从 WaitSet 移动到 Contention List 或 EntryList 中去。**需要注意的是，当调用一个锁对象的 wait 或 notify 方法时，如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁。**

### 锁的升级流程
1. 检查 Mark Word 里面是不是放自己线程的 Thread ID，如果是表示当前线程处于偏向锁状态；
2. 如果 Mark Word 不是当前线程的 Thread ID，锁升级，用 CAS 来执行切换，新的线程根据 Mark Word 里面现有的 Thread ID，通知之前线程暂停，之前线程将 Mark Word 的内容置为空；
3. 两个线程都把锁对象的 HashCode 复制到自己新建的用于存储锁的记录空间，接着开始通过 CAS 操作， 把锁对象的 MarKword 的内容修改为自己新建的记录空间的地址的方式竞争 MarkWord；
4. 第三步中成功执行 CAS 的获得资源，失败的则进入自旋；
5. 自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于 轻量级锁的状态，如果自旋失败；
6. 进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。


### 各种锁的优缺点对比


锁 | 优点 | 缺点 | 适用场景
---|---|---|---
偏向锁 | 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块场景
轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度 | 如果始终得不到锁竞争的线程使用自旋会消耗CPU | 追求响应时间，同步块执行速度非常快
重量级锁 | 线程竞争不使用自旋，不会消耗CPU | 线程阻塞，响应时间缓慢 | 追求吞吐量，同步块执行时间较长

