### 并发编程模型的两个关键问题
- 线程间如何通信？
- 线程间如何同步？

有两种并发模型可以解决这两个问题：
- 消息传递并发模型
- 共享内存并发模型


 | 如何通信 | 如何同步
:-:|:-: |:-:
消息传递并发模型 | 线程之间 **没有公共状态**，线程间的通信必须通过发送消息来显示进行通信 | 发送消息天然同步，因为发送消息总是在接收消息之前，因此同步是隐式的
共享内存并发模型 | 线程之间共享程序的公共状态，通过 **写-读内存中的公共状态** 进行隐式通信 | **必须显式指定某段代码需要在线程之间互斥执行**，同步是显式的

**在 Java 中，使用的是共享内存并发模型**

### Java 内存模型的抽象结构
#### 运行时内存的划分
对于每一个线程来说，栈都是私有的，而堆是共有的。只有堆中的变量是共享变量，内存可见性是针对的共享变量。

#### 既然堆是共享的，为什么在堆中会有内存不可见问题？
这是因为现代计算机为了高效，往往会在高速缓存区中缓存共享变量，因为 CPU 访问缓存区比访问内存要快得多。
> 线程之间的共享变量存在主内存中，每个线程都有一个私有的本地内存，存储了该线程以读、写共享变量的副本。本地内存是 Java 内存模型的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器等。

![](http://concurrent.redspider.group/article/02/imgs/JMM%E6%8A%BD%E8%B1%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

线程 A 无法直接访问线程 B 的工作内存，线程间通信必须经过主内存。

根据 JMM 的规定，线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主内存中读取。

怎么知道这个共享变量的被其他线程更新了呢？这就是 JMM 的功劳了，也是 JMM 存在的必要性之一。JMM 通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性保证。
> Java 中的 volatile 关键字可以保证多线程操作共享变量的可见性以及禁止指令重排序，synchronized 关键字不仅保证可见性，同时也保证了原子性（互斥性）。在更底层，JMM 通过内存屏障来实现内存的可见性以及禁止重排序。为了程序员的方便理解，提出了 happens-before，它更加的简单易懂，从而避免了程序员为了理解内存可见性而去学习复杂的重排序规则以及这些规则的具体实现方法。

### JMM 与 Java 内存区域划分的区别和联系
区别：
- 两者是不同的概念层级。JMM 是抽象的，它是用来描述一组规则，通过这个规则来控制各个变量的访问方式，围绕原子性、有序性、可见性等展开的，而 Java 运行时内存的划分是具体的，是 JVM 运行 Java 程序时，必要的内存划分。

联系：
- 都存在私有数据区域和共享数据区域。一般来说，JMM 中的主内存属于共享数据区域，它是包含了堆和方法区；同样，JMM 中的本地内存属于私有数据区域，包含了程序计数器、本地方法栈、虚拟机栈。